<!-- recording_controls.html: Reusable recording controls component -->





{% if playback %}
  <button id="start-record">Start Recording</button>
  <button id="stop-record" disabled>Stop Recording</button>
  <button id="play-recording" disabled>Play Recording</button>
  <audio id="audio-playback" controls style="display:none;"></audio>
{% endif %}

<script>
let mediaRecorder;
let audioChunks = [];
let audioBlob;

document.addEventListener('DOMContentLoaded', function() {
  const startBtn = document.getElementById('start-record');
  const stopBtn = document.getElementById('stop-record');
  const playBtn = document.getElementById('play-recording');
  const audioPlayback = document.getElementById('audio-playback');
  const audioDataInput = document.getElementById('audio-data');
  const parentForm = audioDataInput ? audioDataInput.closest('form') : null;

  // If playback is false (prompt page), start recording automatically
  {% if not playback %}
  (async function() {
    audioChunks = [];
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.start();
    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
    mediaRecorder.onstop = () => {
      audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
      // Convert to base64 and set in hidden input
      const reader = new FileReader();
      reader.onloadend = function() {
        if (audioDataInput) {
          audioDataInput.value = reader.result.split(',')[1]; // base64 only
          if (parentForm) parentForm.submit();
        }
      };
      reader.readAsDataURL(audioBlob);
    };

    // Ab  


  })();
  {% endif %}

  // If playback is true (mic test), use buttons
  {% if playback %}
  if (startBtn) {
    startBtn.onclick = async function() {
      audioChunks = [];
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.start();
      startBtn.disabled = true;
      stopBtn.disabled = false;
      if (playBtn) playBtn.disabled = true;
      mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
      mediaRecorder.onstop = () => {
        audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        // Convert to base64 and set in hidden input
        const reader = new FileReader();
        reader.onloadend = function() {
          if (audioDataInput) {
            audioDataInput.value = reader.result.split(',')[1]; // base64 only
          }
        };
        reader.readAsDataURL(audioBlob);
        if (audioPlayback) {
          audioPlayback.src = URL.createObjectURL(audioBlob);
          audioPlayback.style.display = 'block';
        }
        if (playBtn) playBtn.disabled = false;
      };
    };
    // Spacebar also stops recording
    window.addEventListener('keydown', function(e) {
      if (e.code === 'Space' && mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });
  }

  if (stopBtn) {
    stopBtn.onclick = function() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    };
  }

  if (playBtn && audioPlayback) {
    playBtn.onclick = function() {
      if (audioBlob) {
        audioPlayback.play();
      }
    };
  }
  {% endif %}

  // Intercept form submit to send audio data
  if (audioDataInput && parentForm) {
    parentForm.addEventListener('submit', function(e) {
      // If no audio data, prevent submit
      if (!audioDataInput.value) {
        e.preventDefault();
        alert('Please record audio before continuing.');
      }
    });
  }
});
</script>
